<!DOCTYPE html>
<html>
  <head>
    <title>My App</title>
    <mete
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="stylesheet" href="appjs/app.min.css" />
    <link rel="stylesheet" href="./main.css" />
  </head>

  <body>
    <div class="app-page" data-page="home">
      <div class="app-content" id="main">
        <div class="app-button left" id="camera-toggle"></div>
        <div
          class="app-button right"
          id="set_setting"
          data-target="setting"
        ></div>
        <div class="app-button left" id="set_summon" data-target="summon"></div>
        <canvas id="canvas" width="360" height="740"></canvas>
        <video
          autoplay
          muted
          playsinline
          id="video"
          width="auto"
          height="auto"
        ></video>
      </div>
    </div>

    <div class="app-page" data-page="setting">
      <div class="app-content" id="setting">
        <div class="app-button" data-target="home"></div>
        <ul class="app-list">
          <label>Display(表示)</label>
          <li><input type="checkbox" clrToggle />日付時間表示</li>
          <li><input type="checkbox" clrToggle />ロゴ表示</li>
          <label>Other(その他)</label>
          <div id="other">
            usagi_AR 2023-<br />
            developer: gochi_AI<br />
            <br />
            thanks List<br />
            *koi<br />
            *cafe lumiere<br />
            *less-ar.com<br />
            *gitpod<br />
            *chatgpt<br />
            *kikinteractive/App.js<br />
            *Figma<br />
            And . u
          </div>
          <label>Link</label>
          <div class="col">
            <li
              id="twitter"
              onclick="window.location='https:\/\/twitter.com\/gochi_AI'"
            ></li>
            <li
              id="github"
              onclick="window.location='https:\/\/github.com\/gochiAI\/usagi_AR'"
            ></li>
          </div>
        </ul>
      </div>
    </div>
    <div class="app-page" data-page="summon">
      <div class="app-content" id="summon">
        <div id="chara"></div>
        <div class="app-button" data-target="home"></div>
      </div>
    </div>
    <script src="appjs/zepto.js"></script>
    <script src="appjs/app.min.js"></script>
    <script>
      var CONSTRAINTS = {
        audio: false,
        video: {
          width: { min: 640, ideal: 1920, max: 1920 },
          height: { min: 480, ideal: 1080, max: 1080 },
          facingMode: null,
        },
      };

      App.controller("home", function (page) {
        $(page).on("appShow", function () {
          const canvas = document.getElementById("canvas");
          var curSTREAM = null;
          const video = document.getElementById("video");
          const ctx = canvas.getContext("2d");

          // localStorageからclickedListの値を取得
          const clickedList = JSON.parse(localStorage.getItem("clickedList"));

          function restart() {
            var windowInnerWidth = window.innerWidth;
            var windowInnerHeight = window.innerHeight;
            canvas.setAttribute("width", windowInnerWidth);
            canvas.setAttribute("height", windowInnerHeight);
            adjustCameraSize(video, windowInnerWidth, windowInnerHeight);
          }
          window.addEventListener("resize", restart);
          restart();

          function loadImage(url) {
            return new Promise((resolve, reject) => {
              const img = new Image();
              img.onload = function () {
                resolve(img);
              };
              img.onerror = function () {
                reject(new Error("Failed to load image: " + url));
              };
              img.src = url;
            });
          }

          async function loadImages(urls) {
            const images = [];
            for (const url of urls) {
              try {
                const image = await loadImage(url);
                images.push(image);
              } catch (error) {
                console.error(error);
              }
            }
            return images;
          }
          async function drawImagesOnCanvas(images) {
            const positions = [];
            let startX = -100;
            let startY = 50;

            for (const image of images) {
              startX += 100;
              const position = { x: startX, y: startY };
              positions.push(position);
              await drawImage(image, position);
            }

            var isMouseDown = false;
            var activeIndex = -1; // アクティブな画像のインデックス

            canvas.addEventListener("mousedown", startDrag);
            canvas.addEventListener("mousemove", drag);
            canvas.addEventListener("mouseup", endDrag);

            canvas.addEventListener("touchstart", startDrag);
canvas.addEventListener("touchmove", drag);
canvas.addEventListener("touchend", endDrag);
  // ドラッグ開始時の処理
  function startDrag(event) {
    isMouseDown = true;
    event.preventDefault();

    const rect = canvas.getBoundingClientRect();
    let offsetX, offsetY;
    if (event.touches) {
      offsetX = event.touches[0].clientX - rect.left;
      offsetY = event.touches[0].clientY - rect.top;
    } else {
      offsetX = event.clientX - rect.left;
      offsetY = event.clientY - rect.top;
    }

    // クリック位置に画像があるかを判定
    activeIndex = positions.findIndex((position, index) => {
      return (
        offsetX >= position.x &&
        offsetX <= position.x + images[index].width &&
        offsetY >= position.y &&
        offsetY <= position.y + images[index].height
      );
    });
  }
  function drag(event) {
    if (isMouseDown && activeIndex !== -1) {
      event.preventDefault();
      const rect = canvas.getBoundingClientRect();
      let offsetX, offsetY;
      if (event.touches) {
        offsetX = event.touches[0].clientX - rect.left;
        offsetY = event.touches[0].clientY - rect.top;
      } else {
        offsetX = event.clientX - rect.left;
        offsetY = event.clientY - rect.top;
      }

      const position = positions[activeIndex];
      position.x = offsetX - images[activeIndex].width / 2;
      position.y = offsetY - images[activeIndex].height / 2;

      drawImages();
      console.log("drag");
    }
  }

  // ドラッグ終了時の処理
  function endDrag(event) {
    event.preventDefault();
    isMouseDown = false;
    activeIndex = -1;

    drawImages();
    console.log("End");
  }
            // すべての画像を描画する関数
            function drawImages() {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              for (let i = 0; i < images.length; i++) {
                const image = images[i];
                const position = positions[i];
                ctx.drawImage(image, position.x, position.y);
              }
            }

            // 画像を描画する関数
            function drawImage(image, position) {
              return new Promise((resolve) => {
                ctx.drawImage(image, position.x, position.y);
                resolve();
              });
            }
          }

          loadImages(clickedList)
            .then((images) => {
              drawImagesOnCanvas(images);
            })
            .catch((error) => {
              console.error(error);
            });

          let useFront = true;
          syncCamera(video, useFront);
          document
            .getElementById("camera-toggle")
            .addEventListener("click", () => {
              useFront = !useFront;
              syncCamera(video, useFront);
            });
          function syncCamera(video, is_front = true) {
            CONSTRAINTS.video.facingMode = is_front
              ? "user"
              : { exact: "environment" };

            if (curSTREAM !== null) {
              curSTREAM.getVideoTracks().forEach((camera) => {
                camera.stop();
              });
            }

            navigator.mediaDevices
              .getUserMedia(CONSTRAINTS)
              .then((stream) => {
                curSTREAM = stream; // 前後の切り替え用に保持

                // <video>とStremaを接続
                video.srcObject = stream;
                video.onloadedmetadata = (e) => {
                  video.play();
                };
              })
              .catch((err) => {
                console.log(`${err.name}: ${err.message}`);
                alert("カメラとの接続時にエラーが発生しました");
              });
          }

          /**
           * 解像度に合わせて<video>サイズを調整する
           *
           * @param {object}  video
           * @param {integer} longside   長辺のピクセル数
           * @param {integer} shortside  短辺のピクセル数
           **/
          function adjustCameraSize(video, longside, shortside) {
            if (window.innerWidth < window.innerHeight) {
              // getUserMediaに食わせる値
              CONSTRAINTS.video.width = shortside;
              CONSTRAINTS.video.height = longside;
              // videoタグのサイズ
              video.width = shortside;
              video.height = longside;
            } else {
              // getUserMediaに食わせる値
              CONSTRAINTS.video.width = longside;
              CONSTRAINTS.video.height = shortside;
              // videoタグのサイズ
              video.width = longside;
              video.height = shortside;
            }
          }
        });
      });

      App.controller("setting", function (page) {
        this.show_date = false;
        this.show_logo = false;
      });
      App.controller("summon", function (page) {
        $(page).on("appShow", function () {
          var Items = localStorage.getItem("selectedImage") || [];
          var CharacterDatas = {
            ekimemo: {
              chino: [
                {
                  "chino-dovey":
                    "aws.gochiusa.com/img/ekimemo/chino_full_dovey.png",
                },
                {
                  "chino-tired":
                    "aws.gochiusa.com/img/ekimemo/chino_full_tired.png",
                },
                {
                  "chino-angry":
                    "aws.gochiusa.com/img/ekimemo/chino_full_angry.png",
                },
                {
                  "chino-smile":
                    "aws.gochiusa.com/img/ekimemo/chino_full_smile.png",
                },
                {
                  "chino-usual":
                    "aws.gochiusa.com/img/ekimemo/chino_full_usual.png",
                },
              ],
              cocoa: [
                {
                  "cocoa-dovey":
                    "aws.gochiusa.com/img/ekimemo/cocoa_full_dovey.png",
                },
                {
                  "cocoa-tired":
                    "aws.gochiusa.com/img/ekimemo/cocoa_full_tired.png",
                },
                {
                  "cocoa-angry":
                    "aws.gochiusa.com/img/ekimemo/cocoa_full_angry.png",
                },
                {
                  "cocoa-smile":
                    "aws.gochiusa.com/img/ekimemo/cocoa_full_smile.png",
                },
                {
                  "cocoa-usual":
                    "aws.gochiusa.com/img/ekimemo/cocoa_full_usual.png",
                },
              ],
              rize: [
                {
                  "rize-dovey":
                    "aws.gochiusa.com/img/ekimemo/rize_full_dovey.png",
                },
                {
                  "rize-tired":
                    "aws.gochiusa.com/img/ekimemo/rize_full_tired.png",
                },
                {
                  "rize-angry":
                    "aws.gochiusa.com/img/ekimemo/rize_full_angry.png",
                },
                {
                  "rize-smile":
                    "aws.gochiusa.com/img/ekimemo/rize_full_smile.png",
                },
                {
                  "rize-usual":
                    "aws.gochiusa.com/img/ekimemo/rize_full_usual.png",
                },
              ],
            },
            lessar: {},
          };

          function generateHTML() {
            let html = "";

            for (const group in CharacterDatas) {
              html += `<details>
    <summary>${group}</summary>`;

              for (const character in CharacterDatas[group]) {
                html += `<details>
        <summary>${character}</summary>
        <div class="character-images">`;

                CharacterDatas[group][character].forEach((expression) => {
                  const expressionName = Object.keys(expression)[0];
                  const imagePath = expression[expressionName];

                  html += `<div>
          <img src="../${imagePath}">
        </div>`;
                });

                html += `</details>`;
              }

              html += `</details>`;
            }

            return html;
          }

          const generatedHTML = generateHTML();
          document.getElementById("chara").innerHTML = generateHTML();
          // クリックした画像のリストを保持する変数
          let clickedList = [];

          // localStorageからクリックした画像のリストを取得
          const storedList = localStorage.getItem("clickedList");
          if (storedList) {
            clickedList = JSON.parse(storedList);
          }

          // 画像クリック時の処理
          function handleImageClick(imagePath) {
            const index = clickedList.indexOf(imagePath);

            if (index === -1) {
              // リストに追加
              clickedList.push(imagePath);
              if (clickedList.length > 5) {
                // リストの長さが5を超える場合、先頭の要素を削除
                clickedList.shift();
              }
            } else {
              // リストから削除
              clickedList.splice(index, 1);
            }

            // リストをlocalStorageに保存
            localStorage.setItem("clickedList", JSON.stringify(clickedList));
          }

          // 画像要素にクリックイベントを追加
          const imageElements = document.querySelectorAll(
            ".character-images img"
          );
          imageElements.forEach((image) => {
            image.addEventListener("click", () => {
              handleImageClick(image.getAttribute("src"));
              updateImageDisplay();
            });
          });

          // 画像の表示を更新する関数
          function updateImageDisplay() {
            // リスト内の画像を強調するためのスタイルを追加
            imageElements.forEach((image) => {
              const imagePath = image.getAttribute("src");
              if (clickedList.includes(imagePath)) {
                image.classList.add("selected");
              } else {
                image.classList.remove("selected");
              }
            });
          }

          // 初期表示時に画像の表示を更新
          updateImageDisplay();
        });
      });

      try {
        App.restore();
      } catch (err) {
        App.load("home");
      }
    </script>
  </body>
  
</html>
